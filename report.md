
## Problem 1 KNN

对于 KNN(K-Nearest Neighbour) 问题，最先想到的解决方案便是采用 KD-Treev的方式，通过对于空间的划分，以减小搜索空间，从而降低运算复杂度。然而对于本问题而言，KD-Tree 似乎对于提高速度没有任何帮助。本问题中，点的个数为 10000 个，则如果能够建立平衡的 KD-Tree 的话，树的深度约为 14 层，而空间维数为 120 维，则大部分的空间没有被划分，这样KD-Tree 之类的基于空间划分以提高搜索速度的算法都会失效。

关于高维数的 KNN 问题，目前没有有效算法，目前处理高维数的 KNN 问题时，往往将 KNN 问题简化为 ANN(Approximate Nearest Neighbor) 问题，即允许一定概率出错，在某个可能性之下得到最近点，这样的算法得到的KNN不一定是最佳的，但一定是不差的。Locality-Sensitive Hashing 则是其中一类有效的算法，通过哈希建立索引，去处多余的搜索，但可能带来一定的错误。相关理论也表明，允许出错的概论越高，运算速度也就越快。然而，本次的作业所关心的问题为 KNN 问题，我们试图寻找准确的最近临点，因此没有使用 ANN 的近似算法。

本次作业的主程序实现了两种不同的串行 KNN 算法，其一为建立 KD-Tree 之后使用 KD-Tree 性质进行搜索（之后成为 KD-Tree 算法），另一算法为枚举两两点距离搜索 KNN （之后称为枚举算法），并在比较两算法的效率后，对第二种算法采用 Control Graph 的思想进行并行化，以进一步提高运算速度，最终效果实现了在 40 个 CPU 上取得了 19 倍的提速比，效率为47.5%。

### 软件环境

本次实验所用到的实验环境为课程所提供的环境，其具体配置如下。

- CentOS Linux release 7.5.1804
- g++ 4.8.5
- C++ Standard 2011

### 实验数据

本次实验中使用的数据为 C++ 默认随机种子生成的120维空间中[0, 1)之间的均匀分布。

### 串行的 KD-Tree 算法与串行的枚举算法

在本次的作业之中，我分别实现了串行的 KD-Tree 算法和串行的枚举算法。

KD-Tree 全称为 K-Dimension Tree，是应用于 K 维空间的二叉查找树，与一般二叉树结构相同，唯一与二叉树不同的是，每一次每个节点将子节点分割成两部分时，按照点所在的某一个纬度进行分割。在本次作业的实现之中，采用了上下限相差最大的一纬作为分割的纬度。使用 KD-Tree 进行搜索的过程中，进行一次深度优先搜索即可获得 K 最近临点。为了搜索 K 个最近邻的点，可以采用优先队列的方式，将最超过前K项距离的点直接出列，并且在 KD-Tree 中搜索的过程中也可以根据分割排除掉某些半空间，可以加速搜索的进行。

在枚举算法当中，对于每个点都构建一个优先队列，在计算两两点之间的距离过程中，不断刷新优先队列中的值，去除距离较大的点，只保留较小距离的点，对两两点距离计算完成之后，即可得到每个点的K最近邻点。

这两种串行的实现方法分别在 knn-kdtree.cpp 和 knn-enumerate.cpp 中。

串行运行这两个程序，使用 chrono 对两程序的执行进行记时，得到两个程序的运行时间分别为。KD-Tree 算法 18.24s，枚举算法 6.04 s。可以看出 KD-Tree 在如此高维的情况下并没有降低运算时间。而实际上，进一步的分析表明，在生成的数据之中，距离最近的两个点的距离为9.17，大于每一个维度上的任何距离，因此 KD-Tree 实际上被没有筛选掉任何的搜索空间，反而增加了搜索的复杂度。

### 枚举算法的并行化

由于枚举算法在串行中具有更高的效率，因此本次作业则将串行算法并行化。并行化的大致思路是，将点分为 m 个分区，这样所有的枚举任务则拆分为 m + m(m-1)/2 个子任务，其中有 m 个子任务是对于分区内部连接进行枚举，而 m(m-1)/2 个子任务是对于两两分区之间连接的枚举。由于在枚举过程中，需要更新每个点所对应的优先队列，因此如果同一个分区同时被两个线程访问，就会导致优先队列的访问冲突，这时为了保证运行正确性，需要给优先队列进行加锁，这样会进行大量的加锁操作，使用大量的时间。因此在本次实现过程中，通过任务的调度，保证了某一个分区所对应的多个任务不能同时被执行。

为了实现任务的调度功能，在程序中定义了 get_task 和 finish_task 函数，分别用来获取一个任务执行，和标明完成一个任务。每一个线程在执行的过程中，首先调用 get_task 获取任务，执行结束后调用 finish_task 完成任务，之后再调用 get_task 获取一个新的任务，直到所有任务执行完成。在 get_task 和 finish_task 的实现之中，保证了同一个分区所对应的多个任务不会同时被执行，实现的方法则是对于每一个任务填写一个 num_locks 的变量，来标明这一任务加了几个锁，每次开始执行一个新的任务之前，需要对该任务所对应的分区关联的所有任务都加一个锁，执行结束后再将锁释放。为了保证执行效率，在程序中增加了两个 set ，分别表示当前可以执行的任务、当前被锁的任务，在每一次 get_task 过程中，检查可执行任务的 set ，如果为空，则需要等待被锁的任务解锁后才能继续执行。

本次作业中的程序实现使用的线程库为 PThread，这一线程库提供了比 OpenMP 更灵活的线程控制，支持互斥锁、条件变量等功能，便于线程之间的同步操作。枚举算法并行化的源代码在 knn-parallel.cpp 之中。

在指定分区数量为80，线程数量为40的情况下，求出每个点的 18 最近临点用时为 0.320 秒，相比串行算法达到了 19 倍的加速比。并行程序的效率低于串行程序的一个主要可能是程序的局部性相比串行较差，使得大量缓存失效，导致效率下降。




